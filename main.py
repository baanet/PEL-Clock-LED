# Large Display Bed Side clock Project
# Michael Lamb May 2025
# will display in either 24hr or 12hr mode (default 24hr)
# added auto time update feature, the clock at midnight on the 1st of the month will check
# with online NTP server anything grater than a 30 second variation will cause the clock
# to update the RTC
# tweaked sidkick code, for when temp drops below 10 deg
# code now imports utc_offset value from local file
# local file is generated by boot.py on startup
# Added try /except funuction to get weather def to handle no internet
# the sidekick display is blanked until new data is recieved
# added try except statements to handle no interent conditions
# if no interent at startup or when sidekick updates the display will blank
# sidekick display will return once internet access is returned
# ver  01/06/25 - Alt
# Hardware change to pwr the time colon from the 2nd digit dec point pin, adding brightness control
# to the led's , changes made to the 12 hour display mode to allow for the colon to show
#
# 12 July 2025(PEL)
# The 'def side_kick()' has been re-writen to:
#   - Read city and country_code from file (/config/weather_config.txt)
#   - Permit a second 'Alt' location to be added e.g. Scoresby,AU;Manchester,UK
#   - The two values will alternate each minute i.e. ciry one on even minutes and city two on odd minutes
#   - Temperature and Humidity are stored in /config/site_one.txt and /config/site_two.txt
#   - The weather refresh rate is set by 'rescan = 15' (about line 180)
#     i.e. sk = 1 (about line 472) by rescan = 15 (about line 180) makes it 1 * 15 = 15 minutes
#
# 13 July 2025(PEL)
# The 'def side_kick()' has been updates to:
#   - Add error trap to create 'weather_config.txt' if it is missing
#   - Tidied up the usage of 'weather_config.txt', now only split if there are 2 locations
#     as the 'City' and 'Country_code' are usable as the variable 'weather'
#   - Rescan no longer uses a file storge, instead it passes 'rescan' back and forwards to the function.
#     See about line 470
#
# 14 and 15 July 2025 (PEL)
# The 'def side_kick()' has been updated to:
#   - Global variables used to share weather data rather than using files to share weather data
#   - Bright colon now controlled by /config/day_of_week.txt existance
#
# 16 July 2025 (PEL)
#   - Introduced a variable 'night_time' to reduce the 'rescan' to every 30 min in the middle of the night
#   - Removed redundant 'global' lines
#
# Notes:
#   - The 'Night/Day Time' display brightness is set at about line 363
#   - The 'bright colon' (Decimal Point)  is used to power the 'Weekday optional display'
#     - The 'weekday display' enable/disable is chexking if '/config/day_of_week.txt' exists - Line 92
#     - This variable is then used to enable/disable 'colon' lines about line 434 and 464
#   - Night_time variable updated at about lines 367 & 373
#   - 
# Info Source - https://electrocredible.com/ds3231-rtc-esp32-micropython/

from machine import SoftI2C, Pin, SoftSPI
from ds3231_gen import * # ds3231_gen.py
import time
#import ahtx0 # Not used
import tm1637 # tm1637.py
import ntptime
import requests
import math
import _thread
import utcoffset # Imports data from utcoffset.py
import neopixel

#from main_ext_sub import side_kick
t_chk = 0

ntptime.host = "pool.ntp.org"
try:
    ntptime.settime()
except:
    print("No Internet")
    
#Man Display
tm = tm1637.TM1637(clk=Pin(13), dio=Pin(10))

#Side Kick Display
tm1 = tm1637.TM1637(clk=Pin(2), dio=Pin(3))

motion = False

sk = 0 #Side kick countdown
rescan = 0

# location_two_temp = location_two_humidity = 0
global weather_config
weather_config = ""

# Check for 'Day_Of_Week' switch - Future Option
global day_of_week
try:
    f = open('config/day_of_week.txt', 'r') #makes an exception if not exist
    Data = f.read() 
    f.close()
    day_of_week = 'yes'
except:
    day_of_week = 'no'

global night_time
night_time = 1

dst1 = 1
dst2 = 0

pir = Pin(1, Pin.IN, Pin.PULL_DOWN)

led = Pin(8, Pin.OUT, Pin.PULL_DOWN)
led.value(1)
#utc_offset = 10

# all LEDS on "88:88"
tm.scroll('Hello')
tm1.brightness(0)
tm1.write([127, 127, 127, 127, 127])
    
# I2C for the RTC
sda_pin=Pin(12)
scl_pin=Pin(11)

i2c = SoftI2C(scl=scl_pin, sda=sda_pin)
#time.sleep(0.5)

#second_thread = _thread.start_new_thread(side_kick, ())

ds = DS3231(i2c)

# I2C for the AHT20 Sensor
i2c1 = SoftI2C(scl=Pin(6), sda=Pin(5))

tm.brightness(0)

def side_kick(rescan):
    print('\nRescan Countdown - ' + str(rescan) + '\n')

    global weather_config
    if len(weather_config) == 0:
        try:
            f = open('/config/weather_config.txt', 'r') 
            weather_config = f.readline()
            f.close()
            weather_config = weather_config.strip()
            print('Loaded Weather Locations (From File) - ' + weather_config + '\n')
        except:
            f = open('/config/weather_config.txt', 'w') 
            weather_config = 'Scoresby,AU'
            f.write(weather_config)
            f.close()
            print('Created Weather Location (Saved to File) - ' + weather_config + '\n')
    
        global alt_check
        alt_check = weather_config.count(";") # Check if two cities to display        

        if alt_check == 1:
            weather_alt = weather_config.split(";")

# Location 1
            weather_config = weather_alt[0]
            print('Location 1 - ' + weather_config)
            weather = str(weather_config.strip())
            global location_one_temp, location_one_humidity
            location_one_temp, location_one_humidity = get_weather(weather)
 #           print('\nOne - ' + str(location_one_temp) +' - ' + str(location_one_humidity))
# Location 2
            weather_two_config = weather_alt[1]
            print('Location 2 - ' + weather_two_config)
            weather = weather_two_config
            global location_two_temp, location_two_humidity
            location_two_temp, location_two_humidity = get_weather(weather)
 #           print('Two - ' + str(location_two_temp) +' - ' + str(location_two_humidity))

        else: # Only one location
            print('Location One - ' + weather_config)
            weather = weather_config
            global location_one_temp, location_one_humidity
            location_one_temp, location_one_humidity = get_weather(weather)

    if rescan == 0:
        rescan = 15 * night_time# Reset counter
    
    if alt_check == 1: # If two sites alternate them
        flip = time.localtime()
        if (flip[4]/2) == (int(flip[4]/2)) : # Primary Location
            flip_alt = 1
        else:
            flip_alt = 2
    
    else: # Default Site One
        flip_alt = 1
    
    show_weather(flip_alt)
    return(rescan)

def get_weather(weather):
    weather = weather.strip() # clean up white spaces
    weather = weather.replace(' ', '%20') # makes it compatible will web request i.e.no real spaces
    
    open_weather_map_api_key = '3b60de64435bd998bb4953fa12adcfec'
    open_weather_map_url = 'http://api.openweathermap.org/data/2.5/weather?q=' + weather + '&APPID=' + open_weather_map_api_key
    try:
        weather_data = requests.get(open_weather_map_url)
        # Get Raw Data - Temperature and Humidity
        raw_temperature = weather_data.json().get('main').get('temp')-273.15
        raw_temperature = str(round(raw_temperature))
        raw_humidity = weather_data.json().get('main').get('humidity')
        raw_humidity = str(round(raw_humidity))
        
        print('Currently - ' + raw_temperature + 'C @ ' + raw_humidity +'%\n')
        
        return raw_temperature, raw_humidity
    
    except:
        print("No internet at this time 0r Coding Error")
        tm1.write(tm1.encode_string("     "))
        tm1.brightness(tm.brightness())
        return 0, 0

def show_weather(flip_alt):
        
        if flip_alt == 1:
            raw_temperature = location_one_temp
            raw_humidity = location_one_humidity
        
        if flip_alt == 2:
            raw_temperature = location_two_temp
            raw_humidity = location_two_humidity
        
        tm1.show(str(int(raw_temperature))+ str(int(raw_humidity)))
        t1 = (str(int(raw_temperature)))
        if len(t1) == 1:
            t1 = '0'+t1
        h1 = (str(raw_humidity))
        if len(h1) != 3:
            h1 = " "+h1
        if flip_alt ==2:
            h1 = 'A1t'
        tm1.write(tm1.encode_string(t1+h1))
        tm1.brightness(tm.brightness())
        
        

def week_day():
    global wd1, np
    tw = time.localtime()
    wd = [6,5,4,3,2,1,0]
    wd1 = wd[tw[6]]
    np = neopixel.NeoPixel(Pin(7), 7)
    np.BRIGHTNESS= .2
    np[wd1] = (255,255,255) # set to red, full brightness
    np.write()
    time.sleep(5)
    
def rtc_update():
    t0 = ds.get_time()#time.localtime(ntptime.time()+utcoffset)#(utc_offset *60 *60))
    year = int(t0[0])
    month = int(t0[1])
    date = int(t0[2])
    day = int(t0[6])
    hour = int(t0[3])+utcoffset #adds / removes 1 hour for DST
    minute = int(t0[4])
    second = int(t0[5])

    now = (year,month,date,hour,minute,second,day,0)
  #  print(now)
    ds.set_time(now)

def time_adjust():
    try:
        t1 = time.mktime(ds.get_time())
        t2 = ntptime.time()+(utc_offset *60 *60)
  #      print(t1, t2, math.isclose(t1,t2,abs_tol=27))
        if math.isclose(t1,t2,abs_tol=27) == False:
            t3 = time.localtime(t2)
            year = int(t3[0])
            month = int(t3[1])
            date = int(t3[2])
            day = int(t3[6])#input("day (1 --> monday , 2 --> Tuesday ... 0 --> Sunday): "))
            hour = int(t3[3])
            minute = int(t3[4])
            second = int(t3[5])

            now = (year,month,date,hour,minute,second,day,0)
    #        print(now)
            #rtc.datetime(now)
            ds.set_time(now)
        else:
            print("Time sync Ok")
    except:
            print("No Interent")
            
def get_dst_dates():
    global sdst, edst
    y1 = t[0]
    N = 2
    # create a new string of last N characters
    y1 = str(y1)[-N:]
    dd1 = 9
    dd2 = 9

    def month_code():
        global m2, m1
        mc = (0,3,3,6,1,4,6,2,5,0,3,5)
        m2 = mc[m1-1]

    leap=0
    y1 = int(y1)
    y2 = (y1+int(y1/4))%7
 #  print(y2)
    #Find 1st sunday in October
    d1 = 0
    while dd1 != 0:
        if dd1 != 0:
            m2 = 0 #October
            d1= d1+1
            dd1 = ((y2+m2+6+d1)-leap)%7
            sdst = d1
        else:
            #print(d1)
            print('')

    #Find 1st sunday in April
    d1 = 0
    y1e = int(y1)
    y2e = (y1e+int(y1e/4))%7
    while dd2 != 0:
        if dd2 != 0:
            m2 = 6 #April
            d1= d1+1
            dd2 = ((y2e+m2+6+d1)-leap)%7
            edst = d1
        else:
            #print(d1)
            print('')
        
 #   print("1st Sun of October in",y1,"is:",sdst)
 #   print("1st Sun of April in",y1e,"is:",edst)

def handle_interrupt(pin):
  global motion
  motion = True
  global interrupt_pin
  interrupt_pin = pin 

try:    
    t=time.localtime(ntptime.time()+utc_offset)
except:
    t=ds.get_time()

# print(ds.get_time())
get_dst_dates()
week_day()

#side_kick()
sk = 0


while True:
    hr24 = pir.value()
  #  print(hr24)
    t = ds.get_time()
    if ds.get_time()[3] in range(7, 22):
        tm.brightness(4) # Daytime brightness of main display
        tm1.brightness(1) # Daytime brightness of sidekick
        np[wd1] = (255,255,255)
        np.write()
        night_time = 1 # Daytime rescan normal
    else:
        tm.brightness(0) # Nighttime brightness Main
        tm1.brightness(0) # Nighttime brightness sidekick
        np[wd1] = (64,64,64)
        np.write()
        night_time = 2 # Nighttime twice as long ie 30 min instead of 15 min
    # check clock for accuarcy 
    if ds.get_time()[2] == 1:
        if t_chk == 0:
            if ds.get_time()[3] == 0:
                if ds.get_time()[4] in range (0,5):
                    t_chk = 1
                    time_adjust()
    else:
         t_chk = 0

    #Check for start of Daylight Savings time   
    t = ds.get_time()
 #   print(t[1], "T1")
    if t[1] == 10:# If October
        print(t[2], "T2")
        print(sdst)
        if t[2] == sdst: #is it the 1st sunday
            print(t[3], "T3")
            if t[3] == 2: # is it 2am
                print(dst2)
                if dst2 == 0: #have I already done this
                    utcoffset = 1 # add 1 hour for DST
                    rtc_update()
                    print("eleven")
                    dst2 = 1
                    dst1 = 1
                    t = ds.get_time()
                    f = open("utcoffset.py","w")
                    f.write("utc_offset = 11")
                    f.close()
                    
     #Check for end of Daylight Savings time
    if t[1] == 4: #is April
        if t[2] == edst: #is the 1st sunday
            #print(t[4])
            if t[3] == 3: #is it 3am
                if dst1 == 1: #have I done this already ?
                    utcoffset = -1 # remove 1 hour for EST 
                    rtc_update()
                    print("Ten")
                    dst1 = 0
                    dst2 = 0
                    t = ds.get_time()
                    f = open("utcoffset.py","w")
                    f.write("utc_offset = 10")
                    f.close()
    print( "\nDate = {}/{}/{}" .format(ds.get_time()[2], ds.get_time()[1],ds.get_time()[0]) )

    # Print the current time in the format: hours:minutes:seconds
    # Format fixed to hh:mm:ss by making min & sec by adding '0' when needed
    fixed_min = str(ds.get_time()[4])
    if len(fixed_min) == 1:
        fixed_min = '0' + fixed_min
    fixed_sec = str(ds.get_time()[5])
    if len(fixed_sec) == 1:
        fixed_sec = '0' + fixed_sec
    print( "Time = {}:" .format(ds.get_time()[3]) + fixed_min + ':' + fixed_sec)
 
    if hr24 == 0:
        if day_of_week == 'no':
            tm.numbers(ds.get_time()[3], ds.get_time()[4], colon = False) # Colon Control
        else:
            tm.numbers(ds.get_time()[3], ds.get_time()[4], colon = True) # Colon Control
    else:
        if ds.get_time()[3] >= 13: # checks afternoon/night 
            if len(str(ds.get_time()[3]-12)) == 1: #convert 24hr time to 12hr time
                hour12=(" "+str(ds.get_time()[3] - 12))# add space to the hour field to balance display
            else:
                hour12=(str(ds.get_time()[3] - 12))
        
        else:
            if len(str(ds.get_time()[3])) == 1:
                hour12 = (" "+str(ds.get_time()[3]))# add space to the hour field to balance display
            else:
                hour12 = (str(ds.get_time()[3]))
            
            if ds.get_time()[3] == 0:# if midnight display 12 instead of 00
                hour12 = "12"
                
        mins12 = str(ds.get_time()[4])
        if len(mins12) == 1:
            mins12 = ("0"+mins12)
        #----- alt changes----------
        show = (hour12+mins12)
        if ds.get_time()[3] >= 13:
            ds3 = ds.get_time()[3] - 12
        else:
            ds3 = ds.get_time()[3]
        #tm.numbers(ds3,ds.get_time()[4]) # send time to the display as numbers    
        # 12 hour version of bright colon test
        if day_of_week == 'no':
            tm.show(show, colon = False) 
        else:
            tm.show(show, colon = True) 
        #----- alt changes----------
    if sk == 0:
        rescan = side_kick(rescan)
        rescan = rescan - 1
        sk = 1 # Delay in updating sidekick in minutes
        
    print(str(60 - ds.get_time()[5]+1) + " Seconds to next update")
#    print(t)
    sk = sk-1
 #   print(ds.get_time()[3],ds.get_time()[4])
    if ds.get_time()[3] == 0:
        print("week day ran")
        if ds.get_time()[4] in range (0,10):
            week_day()
            print("week day ran 1")
    time.sleep(60 - ds.get_time()[5]+1)